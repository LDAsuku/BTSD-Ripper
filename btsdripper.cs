// btsdripper.cs

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text.RegularExpressions;

namespace Blocktool_Super_Deluxe {
	[Serializable]
	public class BlockInfo {
		public enum BlockProgram { ASM, BIN }
		public string blockname;
		public string blockdescription;
		public BlockInfo.BlockProgram blocktype;
		public int blockid; // block ID within database
		public string asmfilename;
		// the below fields are for bin blocks only
		public int offsetmariobelow;
		public int offsetmarioabove;
		public int offsetmariosides;
		public int offsetspriteabovebelow;
		public int offsetspritesides;
		public int offsetcapeside;
		public int offsetfireball;
		public int[] relocoffsets;
		public string binfilename;
	}
	[Serializable]
	public class BlockInsertInfo {
		public int map16;
		public int blockid; // block ID within database
	}
}

namespace BTSDRipper {
	using Blocktool_Super_Deluxe;

	public class BindChanger : SerializationBinder {
		public override Type BindToType(string assemblyName, string typeName) {
			string currentAssembly = Assembly.GetExecutingAssembly().FullName;
			return Type.GetType(typeName + ", " + currentAssembly);
		}
	}

	public class BTSDRipper {
		public static string VERSION = "0.1";

		public static string ReadLineOrDefault(string def) {
			var line = Console.ReadLine();
			if (line == null || line == "") {
				return def;
			}
			return line;
		}

		public static void Pause() {
			Console.WriteLine(Environment.NewLine + "Press any key to exit . . ." + Environment.NewLine);
			Console.ReadKey(true);
		}

		[STAThread]
		public static void Main(string[] args) {
			MainInteractive();
		}

		public static void MainInteractive() {
			Console.ForegroundColor = ConsoleColor.Cyan;
			Console.WriteLine("BTSD ripper " + VERSION + " for GPS 1.3.0+");
			Console.WriteLine("Source code is available at https://github.com/LDAsuku/BTSD-Ripper" + Environment.NewLine);
			Console.ResetColor();
			Console.WriteLine("Make sure to read the entire output of the program. Press Ctrl+C at any time to exit." + Environment.NewLine);

			BinaryFormatter formatter = new BinaryFormatter();
			formatter.Binder = new BindChanger();

			Console.Write("Enter the name of your blocks.db file [blocks.db]: ");
			var blocksdbpath = ReadLineOrDefault("blocks.db");

			ArrayList blocksdb = null;
			try {
				using (FileStream istream = new FileStream(blocksdbpath, FileMode.Open, FileAccess.Read)) {
					try {
						blocksdb = (ArrayList)formatter.Deserialize(istream);
					} catch (SerializationException exc) {
						Console.WriteLine(Environment.NewLine + "Error: " + exc.Message);
						Pause();
						Environment.Exit(1);
					}
				}
			} catch (SystemException exc) {
				Console.WriteLine(Environment.NewLine + "Error: " + exc.Message);
				Pause();
				Environment.Exit(1);
			}

			Console.Write("Enter the name of your romname.dbk file [SMW.dbk]: ");
			var romdbkpath = ReadLineOrDefault("SMW.dbk");

			ArrayList romdbk = null;
			try {
				using (FileStream istream = new FileStream(romdbkpath, FileMode.Open, FileAccess.Read)) {
					try {
						romdbk = (ArrayList)formatter.Deserialize(istream);
					} catch (SerializationException exc) {
						Console.WriteLine(Environment.NewLine + "Error: " + exc.Message);
						Pause();
						Environment.Exit(1);
					}
				}
			} catch (SystemException exc) {
				Console.WriteLine(Environment.NewLine + "Error: " + exc.Message);
				Pause();
				Environment.Exit(1);
			}

			Dictionary<int, BlockInfo> blocksById = new Dictionary<int, BlockInfo>();
			foreach (BlockInfo bi in blocksdb) {
				blocksById.Add(bi.blockid, bi);
			}

			Console.WriteLine(string.Format(Environment.NewLine + "{0} blocks imported from database.", blocksdb.Count));
			Console.WriteLine(string.Format("{0} block insertion records imported from the DBK." + Environment.NewLine, romdbk.Count));

			Console.Write("Specify a path for the output file [btsdripper-output.txt]: ");
			var outputpath = ReadLineOrDefault("btsdripper-output.txt");

			try {
				using (FileStream ostream = new FileStream(outputpath, FileMode.Create, FileAccess.Write))
				using (StreamWriter blocklist = new StreamWriter(ostream)) {
					Console.WriteLine();
					blocklist.WriteLine("; GPS 1.3.0+ block list generated by BTSD Ripper " + VERSION);
					blocklist.WriteLine("; Move this file into GPS's folder and name it list.txt" + Environment.NewLine);

					HashSet<(int, BlockInfo)> blocksUsed = new HashSet<(int, BlockInfo)>();
					List<string> dscs = new List<string>();
					HashSet<string> uniqueBlocks = new HashSet<string>();
					HashSet<(int, BlockInfo)> binBlocks = new HashSet<(int, BlockInfo)>();
					HashSet<(int, BlockInfo)> blocksBelow200 = new HashSet<(int, BlockInfo)>();

					bool warned = false;

					foreach (BlockInsertInfo bii in romdbk) {
						BlockInfo bi = blocksById[bii.blockid];
						if (bi.blocktype == BlockInfo.BlockProgram.ASM) {
							blocksUsed.Add((bii.map16, bi));
							uniqueBlocks.Add(bi.asmfilename);
						} else {
							binBlocks.Add((bii.map16, bi));
						}
					}

					if (blocksUsed.Count > 0) {
						foreach ((int map16, BlockInfo bi) in blocksUsed) {
							if (map16 < 0x200) {
								blocksBelow200.Add((map16, bi));
							} else if (bi.blockdescription != "") {
								string description = Regex.Replace(bi.blockdescription.Replace("\\", @"\\"), @"\r\n?|\r", @"\n");
								dscs.Add(string.Format("{0:X4} 0 {1}", map16, description));
							}
							blocklist.WriteLine(string.Format("{0:X4} {1}", map16, bi.asmfilename));
						}
					}

					if (dscs.Count > 0) {
						blocklist.WriteLine(Environment.NewLine + "; Block descriptions for Lunar Magic" + Environment.NewLine + "@dsc");
						foreach (string dsc in dscs) {
							blocklist.WriteLine(dsc);
						}
						blocklist.WriteLine(Environment.NewLine + "; Make sure to add new blocks BEFORE the @dsc");
					}

					if (binBlocks.Count > 0) {
						Console.ForegroundColor = ConsoleColor.Red;
						Console.WriteLine("Warning: .BIN blocks are not supported by GPS.");
						Console.WriteLine("The following .BIN blocks were not exported:" + Environment.NewLine);
						foreach ((int map16, BlockInfo bi) in binBlocks) {
							Console.WriteLine(string.Format("[{0:X4}] {1} ({2})", map16, bi.blockname, bi.binfilename));
						}
						Console.WriteLine(Environment.NewLine + "You can likely find replacement .ASM blocks on SMWCentral" + Environment.NewLine);
						Console.ResetColor();
						warned = true;
					}

					if (blocksBelow200.Count > 0) {
						Console.ForegroundColor = ConsoleColor.Red;
						Console.WriteLine("Warning: GPS does not allow inserting blocks below Map16 0x200.");
						Console.WriteLine(string.Format("The following {0} blocks were exported but must be relocated manually in order to work with GPS:" + Environment.NewLine, blocksBelow200.Count));
						foreach ((int map16, BlockInfo bi) in blocksBelow200) {
							Console.WriteLine(string.Format("[{0:X4}] {1} ({2})", map16, bi.blockname, bi.asmfilename));
						}
						Console.WriteLine();
						Console.ResetColor();
						warned = true;
					}

					if (warned) {
						Console.WriteLine("Completed with warnings.");
					} else {
						Console.WriteLine("All done!");
					}
					Console.WriteLine(string.Format("{0} blocks exported ({1} unique)" + Environment.NewLine, blocksUsed.Count, uniqueBlocks.Count));

					Console.ForegroundColor = ConsoleColor.Yellow;
					Console.WriteLine("Note: BTSD expects block ASM files to be in the same folder as the executable, whereas GPS expects them in a \"blocks\" subfolder in the same folder as the executable. You will either have to move your blocks into the \"blocks\" subfolder yourself, or work around this by passing \"-b ./\" to GPS. See the included batch file \"GPS here.bat\" for a practical example of passing arguments to GPS.");
					Console.ResetColor();
				}
			} catch (SystemException exc) {
				Console.ResetColor();
				Console.WriteLine(Environment.NewLine + "Error: " + exc.Message);
				Pause();
				Environment.Exit(1);
			}

			Pause();
			Environment.Exit(0);
		}
	}
}
